<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en">
 <!--<![endif]-->
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   Quantization — PyTorch 1.11.0 documentation
  </title>
  <!-- <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> -->
  <!-- Google Analytics -->
  <!-- End Google Analytics -->
  <!-- Preload the theme fonts -->
  <!-- Preload the katex fonts -->
 </head>
 <body class="pytorch-body">
  <div class="pytorch-container">
   <section class="pytorch-content-wrap" data-toggle="wy-nav-shift" id="pytorch-content-wrap">
    <div class="pytorch-content-left">
     <div class="rst-content">
      <div class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
       <article class="pytorch-article" id="pytorch-article" itemprop="articleBody">
        <div class="section" id="quantization">
         <span id="quantization-doc">
         </span>
         <h1>
          Quantization
          <a class="headerlink" href="#quantization" title="Permalink to this headline">
           ¶
          </a>
         </h1>
         <div class="admonition warning">
          <p class="admonition-title">
           Warning
          </p>
          <p>
           Quantization is in beta and subject to change.
          </p>
         </div>
         <div class="section" id="introduction-to-quantization">
          <h2>
           Introduction to Quantization
           <a class="headerlink" href="#introduction-to-quantization" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           Quantization refers to techniques for performing computations and storing
tensors at lower bitwidths than floating point precision. A quantized model
executes some or all of the operations on tensors with integers rather than
floating point values. This allows for a more compact model representation and
the use of high performance vectorized operations on many hardware platforms.
PyTorch supports INT8 quantization compared to typical FP32 models allowing for
a 4x reduction in the model size and a 4x reduction in memory bandwidth
requirements.  Hardware support for  INT8 computations is typically 2 to 4
times faster compared to FP32 compute. Quantization is primarily a technique to
speed up inference and only the forward pass is supported for quantized
operators.
          </p>
          <p>
           PyTorch supports multiple approaches to quantizing a deep learning model. In
most cases the model is trained in FP32 and then the model is converted to
INT8. In addition, PyTorch also supports quantization aware training, which
models quantization errors in both the forward and backward passes using
fake-quantization modules. Note that the entire computation is carried out in
floating point. At the end of quantization aware training, PyTorch provides
conversion functions to convert the trained model into lower precision.
          </p>
          <p>
           At lower level, PyTorch provides a way to represent quantized tensors and
perform operations with them. They can be used to directly construct models
that perform all or part of the computation in lower precision. Higher-level
APIs are provided that incorporate typical workflows of converting FP32 model
to lower precision with minimal accuracy loss.
          </p>
          <p>
           Quantization requires users to be aware of three concepts:
          </p>
          <ol class="arabic simple">
           <li>
            <p>
             Quantization Config (Qconfig): Specifies how weights and activations are to be quantized. Qconfig is needed to create a quantized model.
            </p>
           </li>
           <li>
            <p>
             Backend: Refers to kernels that support quantization, usually with different numerics.
            </p>
           </li>
           <li>
            <p>
             Quantization engine (torch.backends.quantization.engine): When a quantized model is executed, the qengine specifies which backend is to be used for execution. It is important to ensure that the qengine is consistent with the Qconfig.
            </p>
           </li>
          </ol>
         </div>
         <div class="section" id="quantization-api-summary">
          <h2>
           Quantization API Summary
           <a class="headerlink" href="#quantization-api-summary" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           PyTorch provides two different modes of quantization: Eager Mode Quantization and FX Graph Mode Quantization.
          </p>
          <p>
           Eager Mode Quantization is a beta feature. User needs to do fusion and specify where quantization and dequantization happens manually, also it only supports modules and not functionals.
          </p>
          <p>
           FX Graph Mode Quantization is a new automated quantization framework in PyTorch, and currently it’s a prototype feature. It improves upon Eager Mode Quantization by adding support for functionals and automating the quantization process, although people might need to refactor the model to make the model compatible with FX Graph Mode Quantization (symbolically traceable with
           <code class="docutils literal notranslate">
            <span class="pre">
             torch.fx
            </span>
           </code>
           ). Note that FX Graph Mode Quantization is not expected to work on arbitrary models since the model might not be symbolically traceable, we will integrate it into domain libraries like torchvision and users will be able to quantize models similar to the ones in supported domain libraries with FX Graph Mode Quantization. For arbitrary models we’ll provide general guidelines, but to actually make it work, users might need to be familiar with
           <code class="docutils literal notranslate">
            <span class="pre">
             torch.fx
            </span>
           </code>
           , especially on how to make a model symbolically traceable.
          </p>
          <p>
           New users of quantization are encouraged to try out FX Graph Mode Quantization first, if it does not work, user may try to follow the guideline of
           <a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_quant_guide.html">
            using FX Graph Mode Quantization
           </a>
           or fall back to eager mode quantization.
          </p>
          <p>
           The following table compares the differences between Eager Mode Quantization and FX Graph Mode Quantization:
          </p>
          <table class="docutils colwidths-auto align-default">
           <tbody>
            <tr class="row-odd">
             <td>
             </td>
             <td>
              <p>
               Eager Mode
Quantization
              </p>
             </td>
             <td>
              <p>
               FX Graph
Mode
Quantization
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <p>
               Release
Status
              </p>
             </td>
             <td>
              <p>
               beta
              </p>
             </td>
             <td>
              <p>
               prototype
              </p>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <p>
               Operator
Fusion
              </p>
             </td>
             <td>
              <p>
               Manual
              </p>
             </td>
             <td>
              <p>
               Automatic
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <p>
               Quant/DeQuant
Placement
              </p>
             </td>
             <td>
              <p>
               Manual
              </p>
             </td>
             <td>
              <p>
               Automatic
              </p>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <p>
               Quantizing
Modules
              </p>
             </td>
             <td>
              <p>
               Supported
              </p>
             </td>
             <td>
              <p>
               Supported
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <p>
               Quantizing
Functionals/Torch
Ops
              </p>
             </td>
             <td>
              <p>
               Manual
              </p>
             </td>
             <td>
              <p>
               Automatic
              </p>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <p>
               Support for
Customization
              </p>
             </td>
             <td>
              <p>
               Limited Support
              </p>
             </td>
             <td>
              <p>
               Fully
Supported
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <p>
               Quantization Mode
Support
              </p>
             </td>
             <td>
              <p>
               Post Training
Quantization:
Static, Dynamic,
Weight Only
              </p>
              <p>
               Quantiztion Aware
Training:
Static
              </p>
             </td>
             <td>
              <p>
               Post Training
Quantization:
Static, Dynamic,
Weight Only
              </p>
              <p>
               Quantiztion Aware
Training:
Static
              </p>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <p>
               Input/Output
Model Type
              </p>
             </td>
             <td>
              <p>
               <code class="docutils literal notranslate">
                <span class="pre">
                 torch.nn.Module
                </span>
               </code>
              </p>
             </td>
             <td>
              <p>
               <code class="docutils literal notranslate">
                <span class="pre">
                 torch.nn.Module
                </span>
               </code>
               (May need some
refactors to make
the model
compatible with FX
Graph Mode
Quantization)
              </p>
             </td>
            </tr>
           </tbody>
          </table>
          <p>
           There are three types of quantization supported:
          </p>
          <ol class="arabic simple">
           <li>
            <p>
             dynamic quantization (weights quantized with activations read/stored in
floating point and quantized for compute.)
            </p>
           </li>
           <li>
            <p>
             static quantization (weights quantized, activations quantized, calibration
required post training)
            </p>
           </li>
           <li>
            <p>
             static quantization aware training (weights quantized, activations quantized,
quantization numerics modeled during training)
            </p>
           </li>
          </ol>
          <p>
           Please see our
           <a class="reference external" href="https://pytorch.org/blog/introduction-to-quantization-on-pytorch/">
            Introduction to Quantization on Pytorch
           </a>
           blog post
for a more comprehensive overview of the tradeoffs between these quantization
types.
          </p>
          <p>
           Operator coverage varies between dynamic and static quantization and is captured in the table below.
Note that for FX quantization, the corresponding functionals are also supported.
          </p>
          <table class="docutils colwidths-auto align-default">
           <tbody>
            <tr class="row-odd">
             <td>
             </td>
             <td>
              <p>
               Static
Quantization
              </p>
             </td>
             <td>
              <p>
               Dynamic
Quantization
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <div class="line-block">
               <div class="line">
                nn.Linear
               </div>
               <div class="line">
                nn.Conv1d/2d/3d
               </div>
              </div>
             </td>
             <td>
              <div class="line-block">
               <div class="line">
                Y
               </div>
               <div class="line">
                Y
               </div>
              </div>
             </td>
             <td>
              <div class="line-block">
               <div class="line">
                Y
               </div>
               <div class="line">
                N
               </div>
              </div>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <div class="line-block">
               <div class="line">
                nn.LSTM
               </div>
               <div class="line">
                nn.GRU
               </div>
              </div>
             </td>
             <td>
              <div class="line-block">
               <div class="line">
                N
               </div>
               <div class="line">
                N
               </div>
              </div>
             </td>
             <td>
              <div class="line-block">
               <div class="line">
                Y
               </div>
               <div class="line">
                Y
               </div>
              </div>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <div class="line-block">
               <div class="line">
                nn.RNNCell
               </div>
               <div class="line">
                nn.GRUCell
               </div>
               <div class="line">
                nn.LSTMCell
               </div>
              </div>
             </td>
             <td>
              <div class="line-block">
               <div class="line">
                N
               </div>
               <div class="line">
                N
               </div>
               <div class="line">
                N
               </div>
              </div>
             </td>
             <td>
              <div class="line-block">
               <div class="line">
                Y
               </div>
               <div class="line">
                Y
               </div>
               <div class="line">
                Y
               </div>
              </div>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <p>
               nn.EmbeddingBag
              </p>
             </td>
             <td>
              <p>
               Y (activations
are in fp32)
              </p>
             </td>
             <td>
              <p>
               Y
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <p>
               nn.Embedding
              </p>
             </td>
             <td>
              <p>
               Y
              </p>
             </td>
             <td>
              <p>
               N
              </p>
             </td>
            </tr>
            <tr class="row-odd">
             <td>
              <p>
               nn.MultiheadAttention
              </p>
             </td>
             <td>
              <p>
               Not Supported
              </p>
             </td>
             <td>
              <p>
               Not supported
              </p>
             </td>
            </tr>
            <tr class="row-even">
             <td>
              <p>
               Activations
              </p>
             </td>
             <td>
              <p>
               Broadly supported
              </p>
             </td>
             <td>
              <p>
               Un-changed,
computations
stay in fp32
              </p>
             </td>
            </tr>
           </tbody>
          </table>
          <div class="section" id="eager-mode-quantization">
           <h3>
            Eager Mode Quantization
            <a class="headerlink" href="#eager-mode-quantization" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <div class="section" id="dynamic-quantization">
            <h4>
             Dynamic Quantization
             <a class="headerlink" href="#dynamic-quantization" title="Permalink to this headline">
              ¶
             </a>
            </h4>
            <p>
             This is the simplest to apply form of quantization where the weights are
quantized ahead of time but the activations are dynamically quantized
during inference. This is used for situations where the model execution time
is dominated by loading weights from memory rather than computing the matrix
multiplications. This is true for for LSTM and Transformer type models with
small batch size.
            </p>
            <p>
             Diagram:
            </p>
            <div class="highlight-default notranslate">
             <div class="highlight">
              <pre><span></span><span class="c1"># original model</span>
<span class="c1"># all tensors and computations are in floating point</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                 <span class="o">/</span>
<span class="n">linear_weight_fp32</span>

<span class="c1"># dynamically quantized model</span>
<span class="c1"># linear and LSTM weights are in int8</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_int8_w_fp32_inp</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                     <span class="o">/</span>
   <span class="n">linear_weight_int8</span>
</pre>
             </div>
            </div>
            <p>
             API example:
            </p>
            <div class="highlight-default notranslate">
             <div class="highlight">
              <pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># define a floating point model</span>
<span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># create a model instance</span>
<span class="n">model_fp32</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>
<span class="c1"># create a quantized model instance</span>
<span class="n">model_int8</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">quantize_dynamic</span><span class="p">(</span>
    <span class="n">model_fp32</span><span class="p">,</span>  <span class="c1"># the original model</span>
    <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">},</span>  <span class="c1"># a set of layers to dynamically quantize</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">qint8</span><span class="p">)</span>  <span class="c1"># the target dtype for quantized weights</span>

<span class="c1"># run the model</span>
<span class="n">input_fp32</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model_int8</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
</pre>
             </div>
            </div>
            <p>
             To learn more about dynamic quantization please see our
             <a class="reference external" href="https://pytorch.org/tutorials/recipes/recipes/dynamic_quantization.html">
              dynamic quantization tutorial
             </a>
             .
            </p>
           </div>
           <div class="section" id="static-quantization">
            <h4>
             Static Quantization
             <a class="headerlink" href="#static-quantization" title="Permalink to this headline">
              ¶
             </a>
            </h4>
            <p>
             Static quantization quantizes the weights and activations of the model.  It
fuses activations into preceding layers where possible.  It requires
calibration with a representative dataset to determine optimal quantization
parameters for activations. Post Training Quantization is typically used when
both memory bandwidth and compute savings are important with CNNs being a
typical use case.  Static quantization is also known as Post Training
Quantization or PTQ.
            </p>
            <p>
             Diagram:
            </p>
            <div class="highlight-default notranslate">
             <div class="highlight">
              <pre><span></span><span class="c1"># original model</span>
<span class="c1"># all tensors and computations are in floating point</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                    <span class="o">/</span>
    <span class="n">linear_weight_fp32</span>

<span class="c1"># statically quantized model</span>
<span class="c1"># weights and activations are in int8</span>
<span class="n">previous_layer_int8</span> <span class="o">--</span> <span class="n">linear_with_activation_int8</span> <span class="o">--</span> <span class="n">next_layer_int8</span>
                    <span class="o">/</span>
  <span class="n">linear_weight_int8</span>
</pre>
             </div>
            </div>
            <p>
             API Example:
            </p>
            <div class="highlight-default notranslate">
             <div class="highlight">
              <pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># define a floating point model where some layers could be statically quantized</span>
<span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># QuantStub converts tensors from floating point to quantized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="c1"># DeQuantStub converts tensors from quantized to floating point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">DeQuantStub</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># manually specify where tensors will be converted from floating</span>
        <span class="c1"># point to quantized in the quantized model</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># manually specify where tensors will be converted from quantized</span>
        <span class="c1"># to floating point in the quantized model</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># create a model instance</span>
<span class="n">model_fp32</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>

<span class="c1"># model must be set to eval mode for static quantization logic to work</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="c1"># attach a global qconfig, which contains information about what kind</span>
<span class="c1"># of observers to attach. Use 'fbgemm' for server inference and</span>
<span class="c1"># 'qnnpack' for mobile inference. Other quantization configurations such</span>
<span class="c1"># as selecting symmetric or assymetric quantization and MinMax or L2Norm</span>
<span class="c1"># calibration techniques can be specified here.</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">'fbgemm'</span><span class="p">)</span>

<span class="c1"># Fuse the activations to preceding layers, where applicable.</span>
<span class="c1"># This needs to be done manually depending on the model architecture.</span>
<span class="c1"># Common fusions include `conv + relu` and `conv + batchnorm + relu`</span>
<span class="n">model_fp32_fused</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">fuse_modules</span><span class="p">(</span><span class="n">model_fp32</span><span class="p">,</span> <span class="p">[[</span><span class="s1">'conv'</span><span class="p">,</span> <span class="s1">'relu'</span><span class="p">]])</span>

<span class="c1"># Prepare the model for static quantization. This inserts observers in</span>
<span class="c1"># the model that will observe activation tensors during calibration.</span>
<span class="n">model_fp32_prepared</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">model_fp32_fused</span><span class="p">)</span>

<span class="c1"># calibrate the prepared model to determine quantization parameters for activations</span>
<span class="c1"># in a real world setting, the calibration would be done with a representative dataset</span>
<span class="n">input_fp32</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">model_fp32_prepared</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>

<span class="c1"># Convert the observed model to a quantized model. This does several things:</span>
<span class="c1"># quantizes the weights, computes and stores the scale and bias value to be</span>
<span class="c1"># used with each activation tensor, and replaces key operators with quantized</span>
<span class="c1"># implementations.</span>
<span class="n">model_int8</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">model_fp32_prepared</span><span class="p">)</span>

<span class="c1"># run the model, relevant calculations will happen in int8</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model_int8</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
</pre>
             </div>
            </div>
            <p>
             To learn more about static quantization, please see the
             <a class="reference external" href="https://pytorch.org/tutorials/advanced/static_quantization_tutorial.html">
              static quantization tutorial
             </a>
             .
            </p>
           </div>
           <div class="section" id="quantization-aware-training">
            <h4>
             Quantization Aware Training
             <a class="headerlink" href="#quantization-aware-training" title="Permalink to this headline">
              ¶
             </a>
            </h4>
            <p>
             Quantization Aware Training models the effects of quantization during training
allowing for higher accuracy compared to other quantization methods.  During
training, all calculations are done in floating point, with fake_quant modules
modeling the effects of quantization by clamping and rounding to simulate the
effects of INT8.  After model conversion, weights and
activations are quantized, and activations are fused into the preceding layer
where possible.  It is commonly used with CNNs and yields a higher accuracy
compared to static quantization.  Quantization Aware Training is also known as
QAT.
            </p>
            <p>
             Diagram:
            </p>
            <div class="highlight-default notranslate">
             <div class="highlight">
              <pre><span></span><span class="c1"># original model</span>
<span class="c1"># all tensors and computations are in floating point</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                      <span class="o">/</span>
    <span class="n">linear_weight_fp32</span>

<span class="c1"># model with fake_quants for modeling quantization numerics during training</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">fq</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">fq</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                           <span class="o">/</span>
   <span class="n">linear_weight_fp32</span> <span class="o">--</span> <span class="n">fq</span>

<span class="c1"># quantized model</span>
<span class="c1"># weights and activations are in int8</span>
<span class="n">previous_layer_int8</span> <span class="o">--</span> <span class="n">linear_with_activation_int8</span> <span class="o">--</span> <span class="n">next_layer_int8</span>
                     <span class="o">/</span>
   <span class="n">linear_weight_int8</span>
</pre>
             </div>
            </div>
            <p>
             API Example:
            </p>
            <div class="highlight-default notranslate">
             <div class="highlight">
              <pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># define a floating point model where some layers could benefit from QAT</span>
<span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># QuantStub converts tensors from floating point to quantized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="c1"># DeQuantStub converts tensors from quantized to floating point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">DeQuantStub</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># create a model instance</span>
<span class="n">model_fp32</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>

<span class="c1"># model must be set to train mode for QAT logic to work</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

<span class="c1"># attach a global qconfig, which contains information about what kind</span>
<span class="c1"># of observers to attach. Use 'fbgemm' for server inference and</span>
<span class="c1"># 'qnnpack' for mobile inference. Other quantization configurations such</span>
<span class="c1"># as selecting symmetric or assymetric quantization and MinMax or L2Norm</span>
<span class="c1"># calibration techniques can be specified here.</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">'fbgemm'</span><span class="p">)</span>

<span class="c1"># fuse the activations to preceding layers, where applicable</span>
<span class="c1"># this needs to be done manually depending on the model architecture</span>
<span class="n">model_fp32_fused</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">fuse_modules</span><span class="p">(</span><span class="n">model_fp32</span><span class="p">,</span>
    <span class="p">[[</span><span class="s1">'conv'</span><span class="p">,</span> <span class="s1">'bn'</span><span class="p">,</span> <span class="s1">'relu'</span><span class="p">]])</span>

<span class="c1"># Prepare the model for QAT. This inserts observers and fake_quants in</span>
<span class="c1"># the model that will observe weight and activation tensors during calibration.</span>
<span class="n">model_fp32_prepared</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">prepare_qat</span><span class="p">(</span><span class="n">model_fp32_fused</span><span class="p">)</span>

<span class="c1"># run the training loop (not shown)</span>
<span class="n">training_loop</span><span class="p">(</span><span class="n">model_fp32_prepared</span><span class="p">)</span>

<span class="c1"># Convert the observed model to a quantized model. This does several things:</span>
<span class="c1"># quantizes the weights, computes and stores the scale and bias value to be</span>
<span class="c1"># used with each activation tensor, fuses modules where appropriate,</span>
<span class="c1"># and replaces key operators with quantized implementations.</span>
<span class="n">model_fp32_prepared</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">model_int8</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">model_fp32_prepared</span><span class="p">)</span>

<span class="c1"># run the model, relevant calculations will happen in int8</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model_int8</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
</pre>
             </div>
            </div>
            <p>
             To learn more about quantization aware training, please see the
             <a class="reference external" href="https://pytorch.org/tutorials/advanced/static_quantization_tutorial.html">
              QAT
tutorial
             </a>
             .
            </p>
           </div>
          </div>
          <div class="section" id="prototype-fx-graph-mode-quantization">
           <h3>
            (Prototype) FX Graph Mode Quantization
            <a class="headerlink" href="#prototype-fx-graph-mode-quantization" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <p>
            Quantization types supported by FX Graph Mode can be classified in two ways:
           </p>
           <ol class="arabic simple">
            <li>
             <p>
              Post Training Quantization (apply quantization after training, quantization parameters are calculated based on sample calibration data)
             </p>
            </li>
            <li>
             <p>
              Quantization Aware Training (simulate quantization during training so that the quantization parameters can be learned together with the model using training data)
             </p>
            </li>
           </ol>
           <p>
            And then each of these two may include any or all of the following types:
           </p>
           <ul class="simple">
            <li>
             <p>
              Weight Only Quantization (only weight is statically quantized)
             </p>
            </li>
            <li>
             <p>
              Dynamic Quantization (weight is statically quantized, activation is dynamically quantized)
             </p>
            </li>
            <li>
             <p>
              Static Quantization (both weight and activations are statically quantized)
             </p>
            </li>
           </ul>
           <p>
            These two ways of classification are independent, so theoretically we can have 6 different types of quantization.
           </p>
           <p>
            The supported quantization types in FX Graph Mode Quantization are:
           </p>
           <ul class="simple">
            <li>
             <p>
              Post Training Quantization
             </p>
             <ul>
              <li>
               <p>
                Weight Only Quantization
               </p>
              </li>
              <li>
               <p>
                Dynamic Quantization
               </p>
              </li>
              <li>
               <p>
                Static Quantization
               </p>
              </li>
             </ul>
            </li>
            <li>
             <p>
              Quantization Aware Training
             </p>
             <ul>
              <li>
               <p>
                Static Quantization
               </p>
              </li>
             </ul>
            </li>
           </ul>
           <p>
            There are multiple quantization types in post training quantization (weight only, dynamic and static) and the configuration is done through
            <cite>
             qconfig_dict
            </cite>
            (an argument of the
            <cite>
             prepare_fx
            </cite>
            function).
           </p>
           <p>
            API Example:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="kn">import</span> <span class="nn">torch.quantization.quantize_fx</span> <span class="k">as</span> <span class="nn">quantize_fx</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="n">model_fp</span> <span class="o">=</span> <span class="n">UserModel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># post training dynamic/weight_only quantization</span>
<span class="c1">#</span>

<span class="c1"># we need to deepcopy if we still want to keep model_fp unchanged after quantization since quantization apis change the input model</span>
<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">model_to_quantize</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">qconfig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">""</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">default_dynamic_qconfig</span><span class="p">}</span>
<span class="c1"># prepare</span>
<span class="n">model_prepared</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">,</span> <span class="n">qconfig_dict</span><span class="p">)</span>
<span class="c1"># no calibration needed when we only have dynamici/weight_only quantization</span>
<span class="c1"># quantize</span>
<span class="n">model_quantized</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span><span class="n">model_prepared</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># post training static quantization</span>
<span class="c1">#</span>

<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">qconfig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">""</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">'qnnpack'</span><span class="p">)}</span>
<span class="n">model_to_quantize</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="c1"># prepare</span>
<span class="n">model_prepared</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">,</span> <span class="n">qconfig_dict</span><span class="p">)</span>
<span class="c1"># calibrate (not shown)</span>
<span class="c1"># quantize</span>
<span class="n">model_quantized</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span><span class="n">model_prepared</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># quantization aware training for static quantization</span>
<span class="c1">#</span>

<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">qconfig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">""</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">'qnnpack'</span><span class="p">)}</span>
<span class="n">model_to_quantize</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
<span class="c1"># prepare</span>
<span class="n">model_prepared</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_qat_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">,</span> <span class="n">qconfig_dict</span><span class="p">)</span>
<span class="c1"># training loop (not shown)</span>
<span class="c1"># quantize</span>
<span class="n">model_quantized</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span><span class="n">model_prepared</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># fusion</span>
<span class="c1">#</span>
<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">model_fused</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">fuse_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">)</span>
</pre>
            </div>
           </div>
           <p>
            Please see the following tutorials for more information about FX Graph Mode Quantization:
           </p>
           <ul class="simple">
            <li>
             <p>
              <a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_quant_guide.html">
               User Guide on Using FX Graph Mode Quantization
              </a>
             </p>
            </li>
            <li>
             <p>
              <a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_ptq_static.html">
               FX Graph Mode Post Training Static Quantization
              </a>
             </p>
            </li>
            <li>
             <p>
              <a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_ptq_dynamic.html">
               FX Graph Mode Post Training Dynamic Quantization
              </a>
             </p>
            </li>
           </ul>
          </div>
         </div>
         <div class="section" id="quantization-api-reference">
          <h2>
           Quantization API Reference
           <a class="headerlink" href="#quantization-api-reference" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           The
           <a class="reference internal" href="quantization-support.html">
            <span class="doc">
             Quantization API Reference
            </span>
           </a>
           contains documentation
of quantization APIs, such as quantization passes, quantized tensor operations,
and supported quantized modules and functions.
          </p>
          <div class="toctree-wrapper compound">
          </div>
         </div>
         <div class="section" id="quantized-tensors">
          <h2>
           Quantized Tensors
           <a class="headerlink" href="#quantized-tensors" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           PyTorch supports both per tensor and per channel asymmetric linear
quantization. Per tensor means that all the values within the tensor are
scaled the same way. Per channel means that for each dimension, typically
the channel dimension of a tensor, the values
in the tensor are scaled and offset by a different value (effectively
the scale and offset become vectors). This allows for lesser error in converting tensors
to quantized values.
          </p>
          <p>
           The mapping is performed by converting the floating point tensors using
          </p>
          <a class="reference internal image-reference" href="_images/math-quantizer-equation.png">
           <img alt="_images/math-quantizer-equation.png" src="_images/math-quantizer-equation.png" style="width: 40%;"/>
          </a>
          <p>
           Note that, we ensure that zero in floating point is represented with no error
after quantization, thereby ensuring that operations like padding do not cause
additional quantization error.
          </p>
          <p>
           In order to do quantization in PyTorch, we need to be able to represent
quantized data in Tensors. A Quantized Tensor allows for storing
quantized data (represented as int8/uint8/int32) along with quantization
parameters like scale and zero_point. Quantized Tensors allow for many
useful operations making quantized arithmetic easy, in addition to
allowing for serialization of data in a quantized format.
          </p>
         </div>
         <div class="section" id="natively-supported-backends">
          <h2>
           Natively supported backends
           <a class="headerlink" href="#natively-supported-backends" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           Today, PyTorch supports the following backends for running quantized operators efficiently:
          </p>
          <ul class="simple">
           <li>
            <p>
             x86 CPUs with AVX2 support or higher (without AVX2 some operations have
inefficient implementations), via
             <cite>
              fbgemm
             </cite>
             (
             <a class="reference external" href="https://github.com/pytorch/FBGEMM">
              https://github.com/pytorch/FBGEMM
             </a>
             ).
            </p>
           </li>
           <li>
            <p>
             ARM CPUs (typically found in mobile/embedded devices), via
             <cite>
              qnnpack
             </cite>
             (
             <a class="reference external" href="https://github.com/pytorch/pytorch/tree/master/aten/src/ATen/native/quantized/cpu/qnnpack">
              https://github.com/pytorch/pytorch/tree/master/aten/src/ATen/native/quantized/cpu/qnnpack
             </a>
             ).
            </p>
           </li>
          </ul>
          <p>
           The corresponding implementation is chosen automatically based on the PyTorch build mode, though users
have the option to override this by setting
           <cite>
            torch.backends.quantization.engine
           </cite>
           to
           <cite>
            fbgemm
           </cite>
           or
           <cite>
            qnnpack
           </cite>
           .
          </p>
          <div class="admonition note">
           <p class="admonition-title">
            Note
           </p>
           <p>
            At the moment PyTorch doesn’t provide quantized operator implementations on CUDA -
this is the direction for future work. Move the model to CPU in order to test the
quantized functionality.
           </p>
           <p>
            Quantization-aware training (through
            <code class="xref py py-class docutils literal notranslate">
             <span class="pre">
              FakeQuantize
             </span>
            </code>
            ,
which emulates quantized numerics in fp32) supports both CPU and CUDA.
           </p>
          </div>
          <p>
           When preparing a quantized model, it is necessary to ensure that qconfig
and the engine used for quantized computations match the backend on which
the model will be executed. The qconfig controls the type of observers used
during the quantization passes. The qengine controls whether
           <cite>
            fbgemm
           </cite>
           or
           <cite>
            qnnpack
           </cite>
           specific packing function is used when packing weights for linear
and convolution functions and modules. For example:
          </p>
          <p>
           Default settings for fbgemm:
          </p>
          <div class="highlight-default notranslate">
           <div class="highlight">
            <pre><span></span><span class="c1"># set the qconfig for PTQ</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">'fbgemm'</span><span class="p">)</span>
<span class="c1"># or, set the qconfig for QAT</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">'fbgemm'</span><span class="p">)</span>
<span class="c1"># set the qengine to control weight packing</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">quantized</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">'fbgemm'</span>
</pre>
           </div>
          </div>
          <p>
           Default settings for qnnpack:
          </p>
          <div class="highlight-default notranslate">
           <div class="highlight">
            <pre><span></span><span class="c1"># set the qconfig for PTQ</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">'qnnpack'</span><span class="p">)</span>
<span class="c1"># or, set the qconfig for QAT</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">'qnnpack'</span><span class="p">)</span>
<span class="c1"># set the qengine to control weight packing</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">quantized</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">'qnnpack'</span>
</pre>
           </div>
          </div>
         </div>
         <div class="section" id="quantization-customizations">
          <h2>
           Quantization Customizations
           <a class="headerlink" href="#quantization-customizations" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           While default implementations of observers to select the scale factor and bias
based on observed tensor data are provided, developers can provide their own
quantization functions. Quantization can be applied selectively to different
parts of the model or configured differently for different parts of the model.
          </p>
          <p>
           We also provide support for per channel quantization for
           <strong>
            conv2d()
           </strong>
           ,
           <strong>
            conv3d()
           </strong>
           and
           <strong>
            linear()
           </strong>
          </p>
          <p>
           Quantization workflows work by adding (e.g. adding observers as
           <code class="docutils literal notranslate">
            <span class="pre">
             .observer
            </span>
           </code>
           submodule) or replacing (e.g. converting
           <code class="docutils literal notranslate">
            <span class="pre">
             nn.Conv2d
            </span>
           </code>
           to
           <code class="docutils literal notranslate">
            <span class="pre">
             nn.quantized.Conv2d
            </span>
           </code>
           ) submodules in the model’s module hierarchy. It
means that the model stays a regular
           <code class="docutils literal notranslate">
            <span class="pre">
             nn.Module
            </span>
           </code>
           -based instance throughout the
process and thus can work with the rest of PyTorch APIs.
          </p>
          <div class="section" id="quantization-custom-module-api">
           <h3>
            Quantization Custom Module API
            <a class="headerlink" href="#quantization-custom-module-api" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <p>
            Both Eager mode and FX graph mode quantization APIs provide a hook for the user
to specify module quantized in a custom way, with user defined logic for
observation and quantization. The user needs to specify:
           </p>
           <ol class="arabic simple">
            <li>
             <p>
              The Python type of the source fp32 module (existing in the model)
             </p>
            </li>
            <li>
             <p>
              The Python type of the observed module (provided by user). This module needs
to define a
              <cite>
               from_float
              </cite>
              function which defines how the observed module is
created from the original fp32 module.
             </p>
            </li>
            <li>
             <p>
              The Python type of the quantized module (provided by user). This module needs
to define a
              <cite>
               from_observed
              </cite>
              function which defines how the quantized module is
created from the observed module.
             </p>
            </li>
            <li>
             <p>
              A configuration describing (1), (2), (3) above, passed to the quantization APIs.
             </p>
            </li>
           </ol>
           <p>
            The framework will then do the following:
           </p>
           <ol class="arabic simple">
            <li>
             <p>
              during the
              <cite>
               prepare
              </cite>
              module swaps, it will convert every module of type
specified in (1) to the type specified in (2), using the
              <cite>
               from_float
              </cite>
              function of
the class in (2).
             </p>
            </li>
            <li>
             <p>
              during the
              <cite>
               convert
              </cite>
              module swaps, it will convert every module of type
specified in (2) to the type specified in (3), using the
              <cite>
               from_observed
              </cite>
              function
of the class in (3).
             </p>
            </li>
           </ol>
           <p>
            Currently, there is a requirement that
            <cite>
             ObservedCustomModule
            </cite>
            will have a single
Tensor output, and an observer will be added by the framework (not by the user)
on that output. The observer will be stored under the
            <cite>
             activation_post_process
            </cite>
            key
as an attribute of the custom module instance. Relaxing these restrictions may
be done at a future time.
           </p>
           <p>
            Example:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.quantized</span> <span class="k">as</span> <span class="nn">nnq</span>
<span class="kn">import</span> <span class="nn">torch.quantization.quantize_fx</span>

<span class="c1"># original fp32 module to replace</span>
<span class="k">class</span> <span class="nc">CustomModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># custom observed module, provided by user</span>
<span class="k">class</span> <span class="nc">ObservedCustomModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">linear</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_float</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">float_module</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">float_module</span><span class="p">,</span> <span class="s1">'qconfig'</span><span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">float_module</span><span class="o">.</span><span class="n">linear</span><span class="p">)</span>
        <span class="n">observed</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">float_module</span><span class="o">.</span><span class="n">qconfig</span>
        <span class="k">return</span> <span class="n">observed</span>

<span class="c1"># custom quantized module, provided by user</span>
<span class="k">class</span> <span class="nc">StaticQuantCustomModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">linear</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_observed</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">observed_module</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">observed_module</span><span class="p">,</span> <span class="s1">'qconfig'</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">observed_module</span><span class="p">,</span> <span class="s1">'activation_post_process'</span><span class="p">)</span>
        <span class="n">observed_module</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">activation_post_process</span> <span class="o">=</span> \
            <span class="n">observed_module</span><span class="o">.</span><span class="n">activation_post_process</span>
        <span class="n">quantized</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nnq</span><span class="o">.</span><span class="n">Linear</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="n">observed_module</span><span class="o">.</span><span class="n">linear</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">quantized</span>

<span class="c1">#</span>
<span class="c1"># example API call (Eager mode quantization)</span>
<span class="c1">#</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">CustomModule</span><span class="p">())</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="n">prepare_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"float_to_observed_custom_module_class"</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">CustomModule</span><span class="p">:</span> <span class="n">ObservedCustomModule</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">convert_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"observed_to_quantized_custom_module_class"</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">ObservedCustomModule</span><span class="p">:</span> <span class="n">StaticQuantCustomModule</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">m</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">default_qconfig</span>
<span class="n">mp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">prepare_custom_config_dict</span><span class="o">=</span><span class="n">prepare_custom_config_dict</span><span class="p">)</span>
<span class="c1"># calibration (not shown)</span>
<span class="n">mq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
    <span class="n">mp</span><span class="p">,</span> <span class="n">convert_custom_config_dict</span><span class="o">=</span><span class="n">convert_custom_config_dict</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># example API call (FX graph mode quantization)</span>
<span class="c1">#</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">CustomModule</span><span class="p">())</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="n">qconfig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">''</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">default_qconfig</span><span class="p">}</span>
<span class="n">prepare_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"float_to_observed_custom_module_class"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">"static"</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CustomModule</span><span class="p">:</span> <span class="n">ObservedCustomModule</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">convert_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"observed_to_quantized_custom_module_class"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">"static"</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">ObservedCustomModule</span><span class="p">:</span> <span class="n">StaticQuantCustomModule</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">mp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_fx</span><span class="p">(</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">qconfig_dict</span><span class="p">,</span> <span class="n">prepare_custom_config_dict</span><span class="o">=</span><span class="n">prepare_custom_config_dict</span><span class="p">)</span>
<span class="c1"># calibration (not shown)</span>
<span class="n">mq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span>
    <span class="n">mp</span><span class="p">,</span> <span class="n">convert_custom_config_dict</span><span class="o">=</span><span class="n">convert_custom_config_dict</span><span class="p">)</span>
</pre>
            </div>
           </div>
          </div>
         </div>
         <div class="section" id="model-preparation-for-quantization-eager-mode">
          <h2>
           Model Preparation for Quantization (Eager Mode)
           <a class="headerlink" href="#model-preparation-for-quantization-eager-mode" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <p>
           It is necessary to currently make some modifications to the model definition
prior to Eager mode quantization. This is because currently quantization works on a module
by module basis. Specifically, for all quantization techniques, the user needs to:
          </p>
          <ol class="arabic simple">
           <li>
            <p>
             Convert any operations that require output requantization (and thus have
additional parameters) from functionals to module form (for example,
using
             <code class="docutils literal notranslate">
              <span class="pre">
               torch.nn.ReLU
              </span>
             </code>
             instead of
             <code class="docutils literal notranslate">
              <span class="pre">
               torch.nn.functional.relu
              </span>
             </code>
             ).
            </p>
           </li>
           <li>
            <p>
             Specify which parts of the model need to be quantized either by assigning
             <code class="docutils literal notranslate">
              <span class="pre">
               .qconfig
              </span>
             </code>
             attributes on submodules or by specifying
             <code class="docutils literal notranslate">
              <span class="pre">
               qconfig_dict
              </span>
             </code>
             .
For example, setting
             <code class="docutils literal notranslate">
              <span class="pre">
               model.conv1.qconfig
              </span>
              <span class="pre">
               =
              </span>
              <span class="pre">
               None
              </span>
             </code>
             means that the
             <code class="docutils literal notranslate">
              <span class="pre">
               model.conv
              </span>
             </code>
             layer will not be quantized, and setting
             <code class="docutils literal notranslate">
              <span class="pre">
               model.linear1.qconfig
              </span>
              <span class="pre">
               =
              </span>
              <span class="pre">
               custom_qconfig
              </span>
             </code>
             means that the quantization
settings for
             <code class="docutils literal notranslate">
              <span class="pre">
               model.linear1
              </span>
             </code>
             will be using
             <code class="docutils literal notranslate">
              <span class="pre">
               custom_qconfig
              </span>
             </code>
             instead
of the global qconfig.
            </p>
           </li>
          </ol>
          <p>
           For static quantization techniques which quantize activations, the user needs
to do the following in addition:
          </p>
          <ol class="arabic simple">
           <li>
            <p>
             Specify where activations are quantized and de-quantized. This is done using
             <a class="reference internal" href="generated/torch.quantization.QuantStub.html#torch.quantization.QuantStub" title="torch.quantization.QuantStub">
              <code class="xref py py-class docutils literal notranslate">
               <span class="pre">
                QuantStub
               </span>
              </code>
             </a>
             and
             <a class="reference internal" href="generated/torch.quantization.DeQuantStub.html#torch.quantization.DeQuantStub" title="torch.quantization.DeQuantStub">
              <code class="xref py py-class docutils literal notranslate">
               <span class="pre">
                DeQuantStub
               </span>
              </code>
             </a>
             modules.
            </p>
           </li>
           <li>
            <p>
             Use
             <a class="reference internal" href="generated/torch.nn.quantized.FloatFunctional.html#torch.nn.quantized.FloatFunctional" title="torch.nn.quantized.FloatFunctional">
              <code class="xref py py-class docutils literal notranslate">
               <span class="pre">
                torch.nn.quantized.FloatFunctional
               </span>
              </code>
             </a>
             to wrap tensor operations
that require special handling for quantization into modules. Examples
are operations like
             <code class="docutils literal notranslate">
              <span class="pre">
               add
              </span>
             </code>
             and
             <code class="docutils literal notranslate">
              <span class="pre">
               cat
              </span>
             </code>
             which require special handling to
determine output quantization parameters.
            </p>
           </li>
           <li>
            <p>
             Fuse modules: combine operations/modules into a single module to obtain
higher accuracy and performance. This is done using the
             <a class="reference internal" href="generated/torch.quantization.fuse_modules.html#torch.quantization.fuse_modules" title="torch.quantization.fuse_modules">
              <code class="xref py py-func docutils literal notranslate">
               <span class="pre">
                torch.quantization.fuse_modules()
               </span>
              </code>
             </a>
             API, which takes in lists of modules
to be fused. We currently support the following fusions:
[Conv, Relu], [Conv, BatchNorm], [Conv, BatchNorm, Relu], [Linear, Relu]
            </p>
           </li>
          </ol>
         </div>
         <div class="section" id="best-practices">
          <h2>
           Best Practices
           <a class="headerlink" href="#best-practices" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <ol class="arabic simple">
           <li>
            <p>
             Set the
             <code class="docutils literal notranslate">
              <span class="pre">
               reduce_range
              </span>
             </code>
             argument on observers to
             <cite>
              True
             </cite>
             if you are using the
             <code class="docutils literal notranslate">
              <span class="pre">
               fbgemm
              </span>
             </code>
             backend.  This argument prevents overflow on some int8 instructions
by reducing the range of quantized data type by 1 bit.
            </p>
           </li>
          </ol>
         </div>
         <div class="section" id="common-errors">
          <h2>
           Common Errors
           <a class="headerlink" href="#common-errors" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="passing-a-non-quantized-tensor-into-a-quantized-kernel">
           <h3>
            Passing a non-quantized Tensor into a quantized kernel
            <a class="headerlink" href="#passing-a-non-quantized-tensor-into-a-quantized-kernel" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <p>
            If you see an error similar to:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Could</span> <span class="ow">not</span> <span class="n">run</span> <span class="s1">'quantized::some_operator'</span> <span class="k">with</span> <span class="n">arguments</span> <span class="kn">from</span> <span class="nn">the</span> <span class="s1">'CPU'</span> <span class="n">backend</span><span class="o">...</span>
</pre>
            </div>
           </div>
           <p>
            This means that you are trying to pass a non-quantized Tensor to a quantized
kernel. A common workaround is to use
            <code class="docutils literal notranslate">
             <span class="pre">
              torch.quantization.QuantStub
             </span>
            </code>
            to
quantize the tensor.  This needs to be done manually in Eager mode quantization.
An e2e example:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># during the convert step, this will be replaced with a</span>
        <span class="c1"># `quantize_per_tensor` call</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre>
            </div>
           </div>
          </div>
          <div class="section" id="passing-a-quantized-tensor-into-a-non-quantized-kernel">
           <h3>
            Passing a quantized Tensor into a non-quantized kernel
            <a class="headerlink" href="#passing-a-quantized-tensor-into-a-non-quantized-kernel" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <p>
            If you see an error similar to:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Could</span> <span class="ow">not</span> <span class="n">run</span> <span class="s1">'aten::thnn_conv2d_forward'</span> <span class="k">with</span> <span class="n">arguments</span> <span class="kn">from</span> <span class="nn">the</span> <span class="s1">'QuantizedCPU'</span> <span class="n">backend</span><span class="o">.</span>
</pre>
            </div>
           </div>
           <p>
            This means that you are trying to pass a quantized Tensor to a non-quantized
kernel. A common workaround is to use
            <code class="docutils literal notranslate">
             <span class="pre">
              torch.quantization.DeQuantStub
             </span>
            </code>
            to
dequantize the tensor.  This needs to be done manually in Eager mode quantization.
An e2e example:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># this module will not be quantized (see `qconfig = None` logic below)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">DeQuantStub</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># during the convert step, this will be replaced with a</span>
        <span class="c1"># `quantize_per_tensor` call</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># during the convert step, this will be replaced with a</span>
        <span class="c1"># `dequantize` call</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">some_qconfig</span>
<span class="c1"># turn off quantization for conv2</span>
<span class="n">m</span><span class="o">.</span><span class="n">conv2</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="kc">None</span>
</pre>
            </div>
           </div>
          </div>
          <div class="section" id="saving-and-loading-quantized-models">
           <h3>
            Saving and Loading Quantized models
            <a class="headerlink" href="#saving-and-loading-quantized-models" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <p>
            When calling
            <code class="docutils literal notranslate">
             <span class="pre">
              torch.load
             </span>
            </code>
            on a quantized model, if you see an error like:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="ne">AttributeError</span><span class="p">:</span> <span class="s1">'LinearPackedParams'</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">'_modules'</span>
</pre>
            </div>
           </div>
           <p>
            This is because directly saving and loading a quantized model using
            <code class="docutils literal notranslate">
             <span class="pre">
              torch.save
             </span>
            </code>
            and
            <code class="docutils literal notranslate">
             <span class="pre">
              torch.load
             </span>
            </code>
            is not supported. To save/load quantized models, the following ways can be used:
           </p>
           <ol class="arabic simple">
            <li>
             <p>
              Saving/Loading the quantized model state_dict
             </p>
            </li>
           </ol>
           <p>
            An example:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepare_orig</span> <span class="o">=</span> <span class="n">prepare_fx</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">{</span><span class="s1">''</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">})</span>
<span class="n">prepare_orig</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">quantized_orig</span> <span class="o">=</span> <span class="n">convert_fx</span><span class="p">(</span><span class="n">prepare_orig</span><span class="p">)</span>

<span class="c1"># Save/load using state_dict</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">quantized_orig</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>

<span class="n">m2</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepared</span> <span class="o">=</span> <span class="n">prepare_fx</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="p">{</span><span class="s1">''</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">})</span>
<span class="n">quantized</span> <span class="o">=</span> <span class="n">convert_fx</span><span class="p">(</span><span class="n">prepared</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">quantized</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
</pre>
            </div>
           </div>
           <ol class="arabic simple" start="2">
            <li>
             <p>
              Saving/Loading scripted quantized models using
              <code class="docutils literal notranslate">
               <span class="pre">
                torch.jit.save
               </span>
              </code>
              and
              <code class="docutils literal notranslate">
               <span class="pre">
                torch.jit.load
               </span>
              </code>
             </p>
            </li>
           </ol>
           <p>
            An example:
           </p>
           <div class="highlight-default notranslate">
            <div class="highlight">
             <pre><span></span><span class="c1"># Note: using the same model M from previous example</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepare_orig</span> <span class="o">=</span> <span class="n">prepare_fx</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">{</span><span class="s1">''</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">})</span>
<span class="n">prepare_orig</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">quantized_orig</span> <span class="o">=</span> <span class="n">convert_fx</span><span class="p">(</span><span class="n">prepare_orig</span><span class="p">)</span>

<span class="c1"># save/load using scripted model</span>
<span class="n">scripted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">quantized_orig</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">scripted</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">scripted_quantized</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre>
            </div>
           </div>
          </div>
         </div>
         <div class="section" id="numerical-debugging-prototype">
          <h2>
           Numerical Debugging (prototype)
           <a class="headerlink" href="#numerical-debugging-prototype" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="admonition warning">
           <p class="admonition-title">
            Warning
           </p>
           <p>
            Numerical debugging tooling is early prototype and subject to change.
           </p>
          </div>
          <ul class="simple">
           <li>
            <p>
             <a class="reference internal" href="torch.ao.ns._numeric_suite.html#torch-ao-ns-numeric-suite">
              <span class="std std-ref">
               torch.ao.ns._numeric_suite
              </span>
             </a>
             Eager mode numeric suite
            </p>
           </li>
           <li>
            <p>
             <a class="reference internal" href="torch.ao.ns._numeric_suite_fx.html#torch-ao-ns-numeric-suite-fx">
              <span class="std std-ref">
               torch.ao.ns._numeric_suite_fx
              </span>
             </a>
             FX numeric suite
            </p>
           </li>
          </ul>
         </div>
        </div>
       </article>
      </div>
     </div>
    </div>
   </section>
  </div>
 </body>
</html>